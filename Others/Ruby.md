## Ruby

------

### 配列

------

- 配列.shift 
  配列.shift は、配列の先頭の要素を取得し、削除するメソッドのこと。

  ```ruby
  a = [1, 2, 3]
  a.shift # => 1が返る
  a = [2, 3]
  ```

- 配列.join( )
  配列.join( )は、配列の要素を一つの文字列として出力するためのメソッド。繋げる時の「区切り文字」についても、配列.join("x")のように記述することで指定することができる。

  ```ruby
  a = [1, 2, 3]
  a.join(",")
  puts a # => "1, 2, 3" 
  ```

  



#### mapメソッドについて

- 配列のすべての要素に同じ処理をして、新しい配列を作るためのメソッド
- もとの配列の要素はそのままで、処理後の値を集めた新しい配列が返る

```ruby
numbers = [1, 2, 3]
doubled = numbers.map { |n| n * 2 }
puts doubled  # => [2, 4, 6]
```

`numbers.map { |n| n * 2 }` は、「numbersの各要素nを2倍した値を新しい配列にして返す」という意味

#### ＊ map(& : メソッド名 ) の意味

通常の書き方

```ruby
lines = ["abc\n", "def\n", "ghi\n"]
chomped = lines.map { |line| line.chomp }
# これは各要素に対してchompメソッドを実行しています
```

`map(&:chomp)` は、上のコードと**まったく同じ意味**（省略記法を用いている）（各要素に対してchompを呼び出して、という意味）

- `&:chomp` は、`{|x| x.chomp }` というブロックを作って、`map`に渡す省略記法
- `&`は「ブロックとして渡すよ」という意味、`:chomp`は「シンボル（メソッド名）」




### 条件分岐

------

・fizz buzz!

自己回答

```ruby
def chapter02_01(number)
  # コードを記載
  n = number
  for i in 1..n do
    if (i % 15 == 0)
      puts "FizzBuzz!"
    elsif ( i % 3 == 0)
     puts "Fizz!"
    elsif (i % 5 == 0)
      puts "Buzz!"
    else
      puts i
    end
  end
end
chapter02_01(15)
```

模範解答

```ruby
def chapter02_01(number)
  number.times do |num|
    n = num + 1
    if n % 3 == 0 && n % 5 == 0
      puts '"FizzBuzz!"'
    elsif n % 3 == 0
      puts '"Fizz!"'
    elsif n % 5 == 0
      puts '"Buzz!"'
    else
      puts n
    end
  end
end
chapter02_01(20)
```



### データの受け取り

------

#### getsとreadlineの違い

- gets

  -  標準入力から１行だけを読み込むメソッド
  - 戻り値は文字列
  - 改行文字も含めて出力される（必要な場合は .chompで削除）

  ```ruby
  input = gets      # 例: ユーザーが「hello」と入力→ inputには"hello\n"が入る
  input = gets.chomp # "hello"
  ```

- readline

  - `gets`よりも高度な入力機能（コマンド履歴、補完機能など）が使える（`readline`ライブラリをrequireする必要あり）。
  - デフォルトでは改行を含まない
  - getsと同様に標準入力から１行を読み取る
  - 複数行読み取りを行いたい場合は readlines を用いる必要がある

  ```ruby
  require "readline"
  
  input = Readline.readline  # ユーザーが「hello」と入力→ inputには"hello"が入る（改行は含まれません）
  ```

  

### 正規表現

------

正規表現は / パターン / という形で表される。（例 ↓）

```ruby
text = "abc123"
if text =~ /123/
  puts "数字が見つかった！"
end
```

#### よく使われる正規表現の記号

| 記号     | 意味                     | 例                       |
| -------- | ------------------------ | ------------------------ |
| `.`      | 何か1文字                | `/a.c/` → "abc"OK        |
| `*`      | 直前のものが0回以上      | `/a*/` → "", "a", "aa"OK |
| `+`      | 直前のものが1回以上      | `/a+/` → "a", "aa"OK     |
| `?`      | 直前のものが0回か1回     | `/a?/` → "", "a"OK       |
| `[abc]`  | aかbかcのどれか1文字     | `/[abc]/`                |
| `[^abc]` | a,b,c以外の1文字         | `/[^abc]/`               |
| `[0-9]`  | 0〜9のどれか1文字        | `/[0-9]/`                |
| `\d`     | 数字1文字（[0-9]と同じ） | `/\d/`                   |
| `\w`     | 英数字1文字              | `/\w/`                   |
| `\s`     | 空白文字1文字            | `/\s/`                   |
| `^`      | 行頭                     | `/^abc/`                 |
| `$`      | 行末                     | `/abc$/`                 |
| `{n}`    | 直前のものがn回          | `/a{3}/` → "aaa"OK       |
| `{n,m}`  | n回以上m回以下           | `/a{2,4}/`               |
| `( )`    | グループ化               | `/(abc)+/`               |

#### ちょっと応用

1. 文字列を三文字ずつ区切って出力したい場合

```ruby
"abcdefg".scan(/.{1,3}/) #=> ["abc", "def", "g"]
```

| 記号    | 意味                       | 例         |
| ------- | -------------------------- | ---------- |
| `.`     | 何か1文字（なんでもOK）    | `/a.c/`    |
| `{n,m}` | 直前のものがn回以上m回以下 | `/a{2,4}/` |

この二つの組み合わせで表現することができる。

2. 1.の文字数が３の倍数でないver

   ```ruby
   str = "1234567890"
   ary = str.reverse.scan(/.{1,3}/).map(&:reverse).reverse
   puts ary.join(",")  # => 1,234,567,890
   ```

   - まずreverseして後ろから3つずつにする
   - scanで3文字ずつ配列化
   - それぞれreverseして元に戻す（配列の要素内の数字の順番 + 配列要素の順番） 
   - 最後にjoinでカンマ区切り
     

#### Rubyでよく使う正規表現メソッド

- `=~` : パターンにマッチするか調べる
- `scan` : パターンに合う部分をすべて配列で抜き出す
- `sub` : 最初にヒットした部分だけ置換
- `gsub` : ヒットした全部を置換
- `match` : 詳しいマッチ結果を得る
